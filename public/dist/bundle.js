/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@stripe/connect-js/dist/connect.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/@stripe/connect-js/dist/connect.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadConnectAndInitialize: () => (/* binding */ loadConnectAndInitialize)\n/* harmony export */ });\n/* eslint-disable @typescript-eslint/no-empty-function */\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\nconst ConnectElementCommonMethodConfig = {\r\n  setOnLoadError: _listener => {},\r\n  setOnLoaderStart: _listener => {}\r\n};\r\nconst ConnectElementCustomMethodConfig = {\r\n  \"account-onboarding\": {\r\n    setFullTermsOfServiceUrl: _termOfServiceUrl => {},\r\n    setRecipientTermsOfServiceUrl: _recipientTermsOfServiceUrl => {},\r\n    setPrivacyPolicyUrl: _privacyPolicyUrl => {},\r\n    setSkipTermsOfServiceCollection: _skipTermsOfServiceCollection => {},\r\n    setCollectionOptions: _collectionOptions => {},\r\n    setOnExit: _listener => {},\r\n    setOnStepChange: _listener => {}\r\n  },\r\n  \"account-management\": {\r\n    setCollectionOptions: _collectionOptions => {}\r\n  },\r\n  \"notification-banner\": {\r\n    setCollectionOptions: _collectionOptions => {},\r\n    setOnNotificationsChange: _listener => {}\r\n  },\r\n  \"payment-details\": {\r\n    setPayment: _payment => {},\r\n    setOnClose: _listener => {}\r\n  }\r\n};\r\n\r\nconst componentNameMapping = {\r\n  \"account-onboarding\": \"stripe-connect-account-onboarding\",\r\n  payments: \"stripe-connect-payments\",\r\n  \"payment-details\": \"stripe-connect-payment-details\",\r\n  payouts: \"stripe-connect-payouts\",\r\n  \"payouts-list\": \"stripe-connect-payouts-list\",\r\n  balances: \"stripe-connect-balances\",\r\n  \"account-management\": \"stripe-connect-account-management\",\r\n  \"notification-banner\": \"stripe-connect-notification-banner\",\r\n  documents: \"stripe-connect-documents\",\r\n  \"tax-registrations\": \"stripe-connect-tax-registrations\",\r\n  \"tax-settings\": \"stripe-connect-tax-settings\"\r\n};\r\nconst EXISTING_SCRIPT_MESSAGE = \"loadConnect was called but an existing Connect.js script already exists in the document; existing script parameters will be used\";\r\nconst V0_URL = \"https://connect-js.stripe.com/v0.1/connect.js\";\r\nconst V1_URL = \"https://connect-js.stripe.com/v1.0/connect.js\";\r\nconst findScript = () => {\r\n  return document.querySelectorAll(`script[src=\"${V1_URL}\"]`)[0] || document.querySelectorAll(`script[src=\"${V0_URL}\"]`)[0] || null;\r\n};\r\nconst injectScript = () => {\r\n  const script = document.createElement(\"script\");\r\n  script.src = V1_URL;\r\n  const head = document.head;\r\n  if (!head) {\r\n    throw new Error(\"Expected document.head not to be null. Connect.js requires a <head> element.\");\r\n  }\r\n  document.head.appendChild(script);\r\n  return script;\r\n};\r\nlet stripePromise = null;\r\nconst loadScript = () => {\r\n  // Ensure that we only attempt to load Connect.js at most once\r\n  if (stripePromise !== null) {\r\n    return stripePromise;\r\n  }\r\n  stripePromise = new Promise((resolve, reject) => {\r\n    if (typeof window === \"undefined\") {\r\n      reject(\"ConnectJS won't load when rendering code in the server - it can only be loaded on a browser. This error is expected when loading ConnectJS in SSR environments, like NextJS. It will have no impact in the UI, however if you wish to avoid it, you can switch to the `pure` version of the connect.js loader: https://github.com/stripe/connect-js#importing-loadconnect-without-side-effects.\");\r\n      return;\r\n    }\r\n    if (window.StripeConnect) {\r\n      console.warn(EXISTING_SCRIPT_MESSAGE);\r\n    }\r\n    if (window.StripeConnect) {\r\n      const wrapper = createWrapper(window.StripeConnect);\r\n      resolve(wrapper);\r\n      return;\r\n    }\r\n    try {\r\n      let script = findScript();\r\n      if (script) {\r\n        console.warn(EXISTING_SCRIPT_MESSAGE);\r\n      } else if (!script) {\r\n        script = injectScript();\r\n      }\r\n      script.addEventListener(\"load\", () => {\r\n        if (window.StripeConnect) {\r\n          const wrapper = createWrapper(window.StripeConnect);\r\n          resolve(wrapper);\r\n        } else {\r\n          reject(new Error(\"Connect.js did not load the necessary objects\"));\r\n        }\r\n      });\r\n      script.addEventListener(\"error\", () => {\r\n        reject(new Error(\"Failed to load Connect.js\"));\r\n      });\r\n    } catch (error) {\r\n      reject(error);\r\n    }\r\n  });\r\n  return stripePromise;\r\n};\r\nconst hasCustomMethod = tagName => {\r\n  return tagName in ConnectElementCustomMethodConfig;\r\n};\r\nconst initStripeConnect = (stripePromise, initParams) => {\r\n  var _a;\r\n  const eagerClientSecretPromise = (() => {\r\n    try {\r\n      return initParams.fetchClientSecret();\r\n    } catch (error) {\r\n      return Promise.reject(error);\r\n    }\r\n  })();\r\n  const metaOptions = (_a = initParams.metaOptions) !== null && _a !== void 0 ? _a : {};\r\n  const stripeConnectInstance = stripePromise.then(wrapper => wrapper.initialize(Object.assign(Object.assign({}, initParams), {\r\n    metaOptions: Object.assign(Object.assign({}, metaOptions), {\r\n      eagerClientSecretPromise\r\n    })\r\n  })));\r\n  return {\r\n    create: tagName => {\r\n      let htmlName = componentNameMapping[tagName];\r\n      if (!htmlName) {\r\n        htmlName = tagName;\r\n      }\r\n      const element = document.createElement(htmlName);\r\n      const customMethods = hasCustomMethod(tagName) ? ConnectElementCustomMethodConfig[tagName] : {};\r\n      const methods = Object.assign(Object.assign({}, customMethods), ConnectElementCommonMethodConfig);\r\n      for (const method in methods) {\r\n        element[method] = function (value) {\r\n          stripeConnectInstance.then(() => {\r\n            this[`${method}InternalOnly`](value);\r\n          });\r\n        };\r\n      }\r\n      stripeConnectInstance.then(instance => {\r\n        if (!element.isConnected && !element.setConnector) {\r\n          // If the element is not connected to the DOM and the `setConnector` method is not\r\n          // defined, this indicates the element was created before connect.js was loaded, and has\r\n          // not been transformed into a custom element yet\r\n          // To load the custom element code on it, we need to connect and disconnect it to the DOM\r\n          // This isn't a problem, as the element will be invisible, and we know the element is already\r\n          // not currently connected to the DOM\r\n          const oldDisplay = element.style.display;\r\n          element.style.display = \"none\";\r\n          document.body.appendChild(element);\r\n          document.body.removeChild(element);\r\n          element.style.display = oldDisplay;\r\n        }\r\n        if (!element || !element.setConnector) {\r\n          throw new Error(`Element ${tagName} was not transformed into a custom element. Are you using a documented component? See https://docs.stripe.com/connect/supported-embedded-components for a list of supported components`);\r\n        }\r\n        element.setConnector(instance.connect);\r\n      });\r\n      return element;\r\n    },\r\n    update: updateOptions => {\r\n      stripeConnectInstance.then(instance => {\r\n        instance.update(updateOptions);\r\n      });\r\n    },\r\n    debugInstance: () => {\r\n      return stripeConnectInstance;\r\n    },\r\n    logout: () => {\r\n      return stripeConnectInstance.then(instance => {\r\n        return instance.logout();\r\n      });\r\n    }\r\n  };\r\n};\r\nconst createWrapper = stripeConnect => {\r\n  window.StripeConnect = window.StripeConnect || {};\r\n  window.StripeConnect.optimizedLoading = true;\r\n  const wrapper = {\r\n    initialize: params => {\r\n      var _a;\r\n      const metaOptions = (_a = params.metaOptions) !== null && _a !== void 0 ? _a : {};\r\n      const stripeConnectInstance = stripeConnect.init(Object.assign(Object.assign({}, params), {\r\n        metaOptions: Object.assign(Object.assign({}, metaOptions), {\r\n          sdk: true,\r\n          sdkOptions: {\r\n            // This will be replaced by the npm package version when bundling\r\n            sdkVersion: \"3.3.13\"\r\n          }\r\n        })\r\n      }));\r\n      return stripeConnectInstance;\r\n    }\r\n  };\r\n  return wrapper;\r\n};\r\n\r\n// Execute our own script injection after a tick to give users time to do their\r\n// own script injection.\r\nconst stripePromise$1 = Promise.resolve().then(() => loadScript());\r\nlet loadCalled = false;\r\nstripePromise$1.catch(err => {\r\n  if (!loadCalled) {\r\n    console.warn(err);\r\n  }\r\n});\r\nconst loadConnectAndInitialize = initParams => {\r\n  loadCalled = true;\r\n  return initStripeConnect(stripePromise$1, initParams);\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://doctor-appointment-system/./node_modules/@stripe/connect-js/dist/connect.esm.js?");

/***/ }),

/***/ "./src/onboarding.js":
/*!***************************!*\
  !*** ./src/onboarding.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stripe_connect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stripe/connect-js */ \"./node_modules/@stripe/connect-js/dist/connect.esm.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n\n\n// Function to fetch the Stripe account ID from the backend\nvar fetchStripeAccountId = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var response, _yield$response$json, stripe_account_id, _yield$response$json2, error;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return fetch(\"/api/get_stripe_account_id.php\", {\n            method: \"GET\",\n            headers: {\n              \"Content-Type\": \"application/json\"\n            }\n          });\n        case 2:\n          response = _context.sent;\n          if (!response.ok) {\n            _context.next = 11;\n            break;\n          }\n          _context.next = 6;\n          return response.json();\n        case 6:\n          _yield$response$json = _context.sent;\n          stripe_account_id = _yield$response$json.stripe_account_id;\n          return _context.abrupt(\"return\", stripe_account_id);\n        case 11:\n          _context.next = 13;\n          return response.json();\n        case 13:\n          _yield$response$json2 = _context.sent;\n          error = _yield$response$json2.error;\n          console.error(\"Error fetching Stripe account ID:\", error);\n          return _context.abrupt(\"return\", null);\n        case 17:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function fetchStripeAccountId() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n// Function to fetch the client secret\nvar fetchClientSecret = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(connectedAccountId) {\n    var response, _yield$response$json3, error, _yield$response$json4, client_secret;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return fetch(\"/api/account_session.php\", {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n              account: connectedAccountId // The doctor's connected account ID\n            })\n          });\n        case 2:\n          response = _context2.sent;\n          if (response.ok) {\n            _context2.next = 12;\n            break;\n          }\n          _context2.next = 6;\n          return response.json();\n        case 6:\n          _yield$response$json3 = _context2.sent;\n          error = _yield$response$json3.error;\n          console.error(\"Error fetching client secret:\", error);\n          return _context2.abrupt(\"return\", undefined);\n        case 12:\n          _context2.next = 14;\n          return response.json();\n        case 14:\n          _yield$response$json4 = _context2.sent;\n          client_secret = _yield$response$json4.client_secret;\n          return _context2.abrupt(\"return\", client_secret);\n        case 17:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function fetchClientSecret(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n// Function to load Stripe onboarding flow\nvar loadStripeOnboarding = function loadStripeOnboarding(client_secret) {\n  var stripeInstance = (0,_stripe_connect_js__WEBPACK_IMPORTED_MODULE_0__.loadConnectAndInitialize)({\n    publishableKey: \"pk_test_51Q0mWz08GrFUpp2bxZpZ55e16ClgZ5jBudZW6buIyuzozAvD3OpRNb2eRHBcZJjpEtUvPjEeW3QsQj4QFlnZE58H00hT5LUq36\",\n    // Replace with your real publishable key\n    fetchClientSecret: function fetchClientSecret() {\n      return Promise.resolve(client_secret);\n    },\n    appearance: {\n      overlays: \"dialog\",\n      variables: {\n        colorPrimary: \"#dbdfe8\"\n      }\n    }\n  });\n\n  // Get the container where the onboarding component will be embedded\n  var onboardingContainer = document.getElementById(\"onboarding-container\");\n  var onboardingComponent = stripeInstance.create(\"account-onboarding\");\n  onboardingComponent.setOnExit(function () {\n    console.log(\"User exited the onboarding flow\");\n    // Optionally, handle redirection or updates after onboarding\n  });\n  onboardingContainer.appendChild(onboardingComponent);\n};\n\n// Automatically trigger onboarding when the page loads\nwindow.addEventListener(\"load\", /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n  var connectedAccountId, client_secret;\n  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n    while (1) switch (_context3.prev = _context3.next) {\n      case 0:\n        _context3.prev = 0;\n        _context3.next = 3;\n        return fetchStripeAccountId();\n      case 3:\n        connectedAccountId = _context3.sent;\n        if (connectedAccountId) {\n          _context3.next = 7;\n          break;\n        }\n        console.error(\"No Stripe account ID found for the user.\");\n        return _context3.abrupt(\"return\");\n      case 7:\n        _context3.next = 9;\n        return fetchClientSecret(connectedAccountId);\n      case 9:\n        client_secret = _context3.sent;\n        if (client_secret) {\n          // Load the Stripe onboarding if client_secret is retrieved\n          loadStripeOnboarding(client_secret);\n        } else {\n          console.error(\"Failed to fetch client secret for onboarding\");\n        }\n        _context3.next = 16;\n        break;\n      case 13:\n        _context3.prev = 13;\n        _context3.t0 = _context3[\"catch\"](0);\n        console.error(\"Error during onboarding:\", _context3.t0);\n      case 16:\n      case \"end\":\n        return _context3.stop();\n    }\n  }, _callee3, null, [[0, 13]]);\n})));\n\n//# sourceURL=webpack://doctor-appointment-system/./src/onboarding.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/onboarding.js");
/******/ 	
/******/ })()
;